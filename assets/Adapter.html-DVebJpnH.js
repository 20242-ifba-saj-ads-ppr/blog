import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,a as t,o as s}from"./app-CPDrDel3.js";const r={};function i(n,a){return s(),o("div",null,a[0]||(a[0]=[t('<h1 id="adapter" tabindex="-1"><a class="header-anchor" href="#adapter"><span>Adapter</span></a></h1><p><sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup></p><h2 id="intencao" tabindex="-1"><a class="header-anchor" href="#intencao"><span>Intenção</span></a></h2><p>Converter a interface de uma classe em outra interface, esperada pelos clientes. O Adapter permite que classes com interfaces incompatíveis trabalhem em conjunto – o que, de outra forma, seria impossível.</p><p>O padrão Adapter permite que classes com interfaces incompatíveis trabalham em conjunto. É um padrão de projeto estrutural que pode ser usado para resolver problemas de compatibilidade entre classes.</p><h2 id="tambem-conhecido-como" tabindex="-1"><a class="header-anchor" href="#tambem-conhecido-como"><span>Também conhecido como</span></a></h2><p>Wrapper</p><h2 id="motivacao" tabindex="-1"><a class="header-anchor" href="#motivacao"><span>Motivação</span></a></h2><p>Cada biblioteca segue um padrão de desenvolvimento que define como os objetos devem ser criados, compostos e acessados. A partir dessas definições são escolhidos os métodos das classes e interfaces. É possível encontrar varias bibliotecas diferentes para a mesma tarefa ou ate mesmo bibliotecas complementares.</p><p>Considere uma situação onde esta sendo desenvolvida uma aplicação que nela será necessário fazer o controle de um cronograma, tratando as varias questões que envolve os cálculos com datas e horas.</p><p>Em um primeiro momento foi utilizada uma biblioteca chamada Chronaltina. Essa biblioteca possui uma classe chamada <code>ChronaltinaDate</code> que é responsável por fazer adição de datas e horas.</p><p>Todo o sistema foi desenvolvido e funcionou bem, porém, após um tempo foi necessário fazer uma alteração no sistema. Nessa alteração foi necessário fazer com que o sistema trabalhasse com o controle de fuso horário, o que não era previsto pela biblioteca Chronaltina.</p><p>Foi necessário buscar uma nova biblioteca para contemplar esse novo requisito do sistema.</p><p>A equipe de pesquisa encontrou uma nova biblioteca chamada GlobalChronaltinaPlus. Essa biblioteca possui uma classe chamada <code>ChronaltinaPlusDate</code> que é responsável por fazer adição de datas, horas e considera fuso horário.</p><p>Seria extremamente desgastante e custoso para o sistema ter que utilizar duas bibliotecas diferentes para o mesmo trabalho e a refatoração seria muito custosa.</p><figure><img src="https://www.plantuml.com/plantuml/svg/PL312i8m3BttAtASEFo07MGm3ru43uBWhTZY0cqAJUf1yT_j7Cvkvf0NU2zvILeM7ILvfzgfkZhD35qV0sadI7gdnS9JGOurQ6Fs8KMk-Y4tW2Ih1ku1pKzmG4fYkV8ZpaGlzMzmT8cN9YVqzepI3tW9P0k_6ih1DKYMFBAa0PQ8T2kiLEVGai1ckpneOkRKTvNSsbeody-C-0O0" alt="uml diagram" loading="lazy"><figcaption>Uso de duas bibliotecas pelo cliente</figcaption></figure><p>A solução encontrada foi a utilização do padrão Adapter.</p><p>Para que a classe <code>ChronaltinaPlusDate</code> seja utilizada pelo sistema, foi necessário criar uma classe chamada <code>ChronaltinaPlusDateAdapter</code> que é responsável por adaptar a biblioteca <code>ChronaltinaPlusDate</code> para que ela seja utilizada pelo sistema &quot;fazendo de conta&quot; que ela é a <code>ChronaltinaDate</code>.</p><figure><img src="https://www.plantuml.com/plantuml/svg/hPB1QW8n48RlUOevAhe-m2AoHG-z53m81Ok7mKpDG7OYoMmHIz-zMGLhrwtqO0wPENoP_y-VL4anQbDxKrswhSUKOEvY4FJAWWjKWay3UOq0hNqEJKm3r-ubiEYmX8_0zWTuOMcKqg0-rr_GbxaLMFecTKLMNDChgslhEWXTwOtXUl0OD2F7Z9IGDBBi_YFrP76l584EIcB_kcu1szkZPT-ynwKpzqoYC9brFPckn-BDiRKacrv3VVbEY-9E6COO2PcAl7CAuVqU2d3giFSPznWn4rt_EMXe1KoLkzEVEzTl" alt="uml diagram" loading="lazy"><figcaption>Aplicação do padrão Adapter</figcaption></figure><h2 id="estrutura" tabindex="-1"><a class="header-anchor" href="#estrutura"><span>Estrutura</span></a></h2><h3 id="adaptador-de-classe" tabindex="-1"><a class="header-anchor" href="#adaptador-de-classe"><span>Adaptador de classe</span></a></h3><p>um adapter de classe é uma classe que herda de uma classe alvo e implementa uma interface alvo. O adaptador de classe é usado quando é necessário adaptar uma classe existente para que ela possa ser usada em um contexto que exige uma interface diferente.</p><figure><img src="https://www.plantuml.com/plantuml/svg/XP1H2i8m343_SufyAk859iZ46uWN25qs0rrNqqm4yUxMEQSeA1GImajVaZ8PgVMjXtBA91XhJOvnJzgmuGKG5wXyx3dPR5xWgPCAhk0yfOIRYg8nZrIAxAGMj_j9A_BPE5IlRfGsUcuvMFgdXQsNpE5oFP80eJD6bUPWsDLFHr6ClVcVeKH8E4p1apQI4hp9IJFpUO0CvFUrsGho1dXN0vGv7QxuY3S0" alt="uml diagram" loading="lazy"><figcaption>Estrutura do Adapter de classe</figcaption></figure><h3 id="adaptador-de-objeto" tabindex="-1"><a class="header-anchor" href="#adaptador-de-objeto"><span>Adaptador de objeto</span></a></h3><p>um adapter de objeto é um objeto que encapsula um objeto alvo e fornece uma interface diferente para o objeto alvo. O adaptador de objeto é usado quando é necessário adaptar um objeto existente para que ele possa ser usado em um contexto que exige uma interface diferente.</p><figure><img src="https://www.plantuml.com/plantuml/svg/VP1T2i8m48JVznJpg4WzG0MfU0Fn0Z7PIY0_DTdw8jxTQ1iHH9zsM6RcMxRBefACtb7tLZO8frvfnb6bCmjk1AoG-39obiMonJLQGtVIJkMCdL63CC-kFB2slTM7l-u4wmV7deFaJqe3DRMrjVO7UkzioQBPpccglMLJanIYC4vH97h4lg9BumnPVnsx8Gu6pnnHL-JhCTDy0000" alt="uml diagram" loading="lazy"><figcaption>Estrutura do Adapter de objeto</figcaption></figure><h2 id="participantes" tabindex="-1"><a class="header-anchor" href="#participantes"><span>Participantes</span></a></h2><ul><li><strong>Client (Client)</strong>: é o cliente que usa a interface Target (ChronaltinaDate).</li><li><strong>Target (ChronaltinaDate)</strong>: define a interface que o cliente usa.</li><li><strong>Adaptee (ChronaltinaPlusDate)</strong>: é a classe que precisa ser adaptada para que ela possa ser usada pelo cliente.</li><li><strong>Adapter (ChronaltinaPlusDateAdapter)</strong>: é a classe que adapta a classe Adaptee para que ela possa ser usada pelo cliente.</li></ul><h2 id="referencias" tabindex="-1"><a class="header-anchor" href="#referencias"><span>Referências</span></a></h2><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="footnote1" class="footnote-item"><p>GAMMA, Erich. et al. Padrões de projetos: Soluções reutilizáveis de software orientados a objetos Bookman editora, 2009. <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p></li></ol></section>',31)]))}const c=e(r,[["render",i]]),p=JSON.parse('{"path":"/posts/GOF/estruturais/Adapter.html","title":"Adapter","lang":"pt-BR","frontmatter":{"icon":"edit","date":"2025-02-26T23:20:00.000Z","tag":["adapter","gof"],"category":["aula"],"order":1,"excerpt":"Apresentação do Padrão de Projeto Adapter"},"headers":[{"level":2,"title":"Intenção","slug":"intencao","link":"#intencao","children":[]},{"level":2,"title":"Também conhecido como","slug":"tambem-conhecido-como","link":"#tambem-conhecido-como","children":[]},{"level":2,"title":"Motivação","slug":"motivacao","link":"#motivacao","children":[]},{"level":2,"title":"Estrutura","slug":"estrutura","link":"#estrutura","children":[{"level":3,"title":"Adaptador de classe","slug":"adaptador-de-classe","link":"#adaptador-de-classe","children":[]},{"level":3,"title":"Adaptador de objeto","slug":"adaptador-de-objeto","link":"#adaptador-de-objeto","children":[]}]},{"level":2,"title":"Participantes","slug":"participantes","link":"#participantes","children":[]},{"level":2,"title":"Referências","slug":"referencias","link":"#referencias","children":[]}],"git":{"createdTime":1741729686000,"updatedTime":1741729686000,"contributors":[{"name":"Leandro Costa","email":"leandro.costa@ifba.edu.br","commits":1}]},"readingTime":{"minutes":2.34,"words":701},"filePathRelative":"posts/GOF/estruturais/Adapter.md","localizedDate":"26 de fevereiro de 2025"}');export{c as comp,p as data};
